// Autogenerated file.
use super::element_list::ElementList;
use super::kind::SyntaxKind;
use super::{
    GreenId, GreenInternalNode, GreenInterner, GreenNode, SyntaxNode, SyntaxToken, TypedSyntaxNode,
};
use std::ops::Deref;
pub struct Empty {
    node: SyntaxNode,
    children: Vec<SyntaxNode>,
}
impl Empty {
    pub fn new_green(db: &dyn GreenInterner) -> GreenId {
        let children: Vec<GreenId> = vec![];
        let width = children.iter().map(|id| db.lookup_intern_green(*id).width()).sum();
        db.intern_green(GreenNode::Internal(GreenInternalNode {
            kind: SyntaxKind::Empty,
            children,
            width,
        }))
    }
}
impl TypedSyntaxNode for Empty {
    fn missing(db: &dyn GreenInterner) -> GreenId {
        let children: Vec<GreenId> = vec![];
        db.intern_green(GreenNode::Internal(GreenInternalNode {
            kind: SyntaxKind::Empty,
            children,
            width: 0,
        }))
    }
    fn from_syntax_node(db: &dyn GreenInterner, node: SyntaxNode) -> Self {
        let green = db.lookup_intern_green(node.0.green);
        match green {
            GreenNode::Internal(internal) => {
                if internal.kind != SyntaxKind::Empty {
                    panic!(
                        "Unexpected SyntaxKind {:?}. Expected {:?}.",
                        internal.kind,
                        SyntaxKind::Empty
                    );
                }
                let children = node.children(db);
                Self { node, children }
            }
            GreenNode::Token(token) => {
                panic!("Unexpected Token {:?}. Expected {:?}.", token, SyntaxKind::Empty);
            }
        }
    }
}
pub struct Terminal {
    node: SyntaxNode,
    children: Vec<SyntaxNode>,
}
impl Terminal {
    pub fn new_green(
        db: &dyn GreenInterner,
        leading_trivia: GreenId,
        token: GreenId,
        trailing_trivia: GreenId,
    ) -> GreenId {
        let children: Vec<GreenId> = vec![leading_trivia, token, trailing_trivia];
        let width = children.iter().map(|id| db.lookup_intern_green(*id).width()).sum();
        db.intern_green(GreenNode::Internal(GreenInternalNode {
            kind: SyntaxKind::Terminal,
            children,
            width,
        }))
    }
    pub fn leading_trivia(&self, db: &dyn GreenInterner) -> Trivia {
        let child = self.children[0].clone();
        Trivia::from_syntax_node(db, child)
    }
    pub fn token(&self, db: &dyn GreenInterner) -> SyntaxToken {
        let child = self.children[1].clone();
        SyntaxToken::from_syntax_node(db, child)
    }
    pub fn trailing_trivia(&self, db: &dyn GreenInterner) -> Trivia {
        let child = self.children[2].clone();
        Trivia::from_syntax_node(db, child)
    }
}
impl TypedSyntaxNode for Terminal {
    fn missing(db: &dyn GreenInterner) -> GreenId {
        let children: Vec<GreenId> =
            vec![Trivia::missing(db), SyntaxToken::missing(db), Trivia::missing(db)];
        db.intern_green(GreenNode::Internal(GreenInternalNode {
            kind: SyntaxKind::Terminal,
            children,
            width: 0,
        }))
    }
    fn from_syntax_node(db: &dyn GreenInterner, node: SyntaxNode) -> Self {
        let green = db.lookup_intern_green(node.0.green);
        match green {
            GreenNode::Internal(internal) => {
                if internal.kind != SyntaxKind::Terminal {
                    panic!(
                        "Unexpected SyntaxKind {:?}. Expected {:?}.",
                        internal.kind,
                        SyntaxKind::Terminal
                    );
                }
                let children = node.children(db);
                Self { node, children }
            }
            GreenNode::Token(token) => {
                panic!("Unexpected Token {:?}. Expected {:?}.", token, SyntaxKind::Terminal);
            }
        }
    }
}
pub struct Trivia(ElementList<Trivium, 1>);
impl Deref for Trivia {
    type Target = ElementList<Trivium, 1>;
    fn deref(&self) -> &Self::Target {
        &self.0
    }
}
impl Trivia {
    pub fn new_green(db: &dyn GreenInterner, children: Vec<GreenId>) -> GreenId {
        let width = children.iter().map(|id| db.lookup_intern_green(*id).width()).sum();
        db.intern_green(GreenNode::Internal(GreenInternalNode {
            kind: SyntaxKind::Trivia,
            children,
            width,
        }))
    }
}
impl TypedSyntaxNode for Trivia {
    fn missing(db: &dyn GreenInterner) -> GreenId {
        db.intern_green(GreenNode::Internal(GreenInternalNode {
            kind: SyntaxKind::Trivia,
            children: vec![],
            width: 0,
        }))
    }
    fn from_syntax_node(db: &dyn GreenInterner, node: SyntaxNode) -> Self {
        Self(ElementList::new(node))
    }
}
pub enum Trivium {
    TriviumSingleLineComment(TriviumSingleLineComment),
    TriviumWhitespace(TriviumWhitespace),
    TriviumNewline(TriviumNewline),
    Empty(Empty),
}
impl TypedSyntaxNode for Trivium {
    fn missing(db: &dyn GreenInterner) -> GreenId {
        db.intern_green(GreenNode::Internal(GreenInternalNode {
            kind: SyntaxKind::Empty,
            children: vec![],
            width: 0,
        }))
    }
    fn from_syntax_node(db: &dyn GreenInterner, node: SyntaxNode) -> Self {
        let green = db.lookup_intern_green(node.0.green);
        if let GreenNode::Internal(internal) = green {
            match internal.kind {
                SyntaxKind::TriviumSingleLineComment => {
                    return Trivium::TriviumSingleLineComment(
                        TriviumSingleLineComment::from_syntax_node(db, node),
                    )
                }
                SyntaxKind::TriviumWhitespace => {
                    return Trivium::TriviumWhitespace(TriviumWhitespace::from_syntax_node(
                        db, node,
                    ))
                }
                SyntaxKind::TriviumNewline => {
                    return Trivium::TriviumNewline(TriviumNewline::from_syntax_node(db, node))
                }
                SyntaxKind::Empty => return Trivium::Empty(Empty::from_syntax_node(db, node)),
                _ => {
                    panic!("Unexpected syntax kind {:?} when constructing $(&name).", internal.kind)
                }
            }
        }
        panic!("Expected an internal node.");
    }
}
pub struct TriviumSingleLineComment {
    node: SyntaxNode,
    children: Vec<SyntaxNode>,
}
impl TriviumSingleLineComment {
    pub fn new_green(db: &dyn GreenInterner, token: GreenId) -> GreenId {
        let children: Vec<GreenId> = vec![token];
        let width = children.iter().map(|id| db.lookup_intern_green(*id).width()).sum();
        db.intern_green(GreenNode::Internal(GreenInternalNode {
            kind: SyntaxKind::TriviumSingleLineComment,
            children,
            width,
        }))
    }
    pub fn token(&self, db: &dyn GreenInterner) -> SyntaxToken {
        let child = self.children[0].clone();
        SyntaxToken::from_syntax_node(db, child)
    }
}
impl TypedSyntaxNode for TriviumSingleLineComment {
    fn missing(db: &dyn GreenInterner) -> GreenId {
        let children: Vec<GreenId> = vec![SyntaxToken::missing(db)];
        db.intern_green(GreenNode::Internal(GreenInternalNode {
            kind: SyntaxKind::TriviumSingleLineComment,
            children,
            width: 0,
        }))
    }
    fn from_syntax_node(db: &dyn GreenInterner, node: SyntaxNode) -> Self {
        let green = db.lookup_intern_green(node.0.green);
        match green {
            GreenNode::Internal(internal) => {
                if internal.kind != SyntaxKind::TriviumSingleLineComment {
                    panic!(
                        "Unexpected SyntaxKind {:?}. Expected {:?}.",
                        internal.kind,
                        SyntaxKind::TriviumSingleLineComment
                    );
                }
                let children = node.children(db);
                Self { node, children }
            }
            GreenNode::Token(token) => {
                panic!(
                    "Unexpected Token {:?}. Expected {:?}.",
                    token,
                    SyntaxKind::TriviumSingleLineComment
                );
            }
        }
    }
}
pub struct TriviumWhitespace {
    node: SyntaxNode,
    children: Vec<SyntaxNode>,
}
impl TriviumWhitespace {
    pub fn new_green(db: &dyn GreenInterner, token: GreenId) -> GreenId {
        let children: Vec<GreenId> = vec![token];
        let width = children.iter().map(|id| db.lookup_intern_green(*id).width()).sum();
        db.intern_green(GreenNode::Internal(GreenInternalNode {
            kind: SyntaxKind::TriviumWhitespace,
            children,
            width,
        }))
    }
    pub fn token(&self, db: &dyn GreenInterner) -> SyntaxToken {
        let child = self.children[0].clone();
        SyntaxToken::from_syntax_node(db, child)
    }
}
impl TypedSyntaxNode for TriviumWhitespace {
    fn missing(db: &dyn GreenInterner) -> GreenId {
        let children: Vec<GreenId> = vec![SyntaxToken::missing(db)];
        db.intern_green(GreenNode::Internal(GreenInternalNode {
            kind: SyntaxKind::TriviumWhitespace,
            children,
            width: 0,
        }))
    }
    fn from_syntax_node(db: &dyn GreenInterner, node: SyntaxNode) -> Self {
        let green = db.lookup_intern_green(node.0.green);
        match green {
            GreenNode::Internal(internal) => {
                if internal.kind != SyntaxKind::TriviumWhitespace {
                    panic!(
                        "Unexpected SyntaxKind {:?}. Expected {:?}.",
                        internal.kind,
                        SyntaxKind::TriviumWhitespace
                    );
                }
                let children = node.children(db);
                Self { node, children }
            }
            GreenNode::Token(token) => {
                panic!(
                    "Unexpected Token {:?}. Expected {:?}.",
                    token,
                    SyntaxKind::TriviumWhitespace
                );
            }
        }
    }
}
pub struct TriviumNewline {
    node: SyntaxNode,
    children: Vec<SyntaxNode>,
}
impl TriviumNewline {
    pub fn new_green(db: &dyn GreenInterner, token: GreenId) -> GreenId {
        let children: Vec<GreenId> = vec![token];
        let width = children.iter().map(|id| db.lookup_intern_green(*id).width()).sum();
        db.intern_green(GreenNode::Internal(GreenInternalNode {
            kind: SyntaxKind::TriviumNewline,
            children,
            width,
        }))
    }
    pub fn token(&self, db: &dyn GreenInterner) -> SyntaxToken {
        let child = self.children[0].clone();
        SyntaxToken::from_syntax_node(db, child)
    }
}
impl TypedSyntaxNode for TriviumNewline {
    fn missing(db: &dyn GreenInterner) -> GreenId {
        let children: Vec<GreenId> = vec![SyntaxToken::missing(db)];
        db.intern_green(GreenNode::Internal(GreenInternalNode {
            kind: SyntaxKind::TriviumNewline,
            children,
            width: 0,
        }))
    }
    fn from_syntax_node(db: &dyn GreenInterner, node: SyntaxNode) -> Self {
        let green = db.lookup_intern_green(node.0.green);
        match green {
            GreenNode::Internal(internal) => {
                if internal.kind != SyntaxKind::TriviumNewline {
                    panic!(
                        "Unexpected SyntaxKind {:?}. Expected {:?}.",
                        internal.kind,
                        SyntaxKind::TriviumNewline
                    );
                }
                let children = node.children(db);
                Self { node, children }
            }
            GreenNode::Token(token) => {
                panic!("Unexpected Token {:?}. Expected {:?}.", token, SyntaxKind::TriviumNewline);
            }
        }
    }
}
pub struct Identifier {
    node: SyntaxNode,
    children: Vec<SyntaxNode>,
}
impl Identifier {
    pub fn new_green(db: &dyn GreenInterner, terminal: GreenId) -> GreenId {
        let children: Vec<GreenId> = vec![terminal];
        let width = children.iter().map(|id| db.lookup_intern_green(*id).width()).sum();
        db.intern_green(GreenNode::Internal(GreenInternalNode {
            kind: SyntaxKind::Identifier,
            children,
            width,
        }))
    }
    pub fn terminal(&self, db: &dyn GreenInterner) -> Terminal {
        let child = self.children[0].clone();
        Terminal::from_syntax_node(db, child)
    }
}
impl TypedSyntaxNode for Identifier {
    fn missing(db: &dyn GreenInterner) -> GreenId {
        let children: Vec<GreenId> = vec![Terminal::missing(db)];
        db.intern_green(GreenNode::Internal(GreenInternalNode {
            kind: SyntaxKind::Identifier,
            children,
            width: 0,
        }))
    }
    fn from_syntax_node(db: &dyn GreenInterner, node: SyntaxNode) -> Self {
        let green = db.lookup_intern_green(node.0.green);
        match green {
            GreenNode::Internal(internal) => {
                if internal.kind != SyntaxKind::Identifier {
                    panic!(
                        "Unexpected SyntaxKind {:?}. Expected {:?}.",
                        internal.kind,
                        SyntaxKind::Identifier
                    );
                }
                let children = node.children(db);
                Self { node, children }
            }
            GreenNode::Token(token) => {
                panic!("Unexpected Token {:?}. Expected {:?}.", token, SyntaxKind::Identifier);
            }
        }
    }
}
pub enum Expr {
    ExprPath(ExprPath),
    ExprLiteral(ExprLiteral),
    ExprParenthesized(ExprParenthesized),
    ExprUnary(ExprUnary),
    ExprBinary(ExprBinary),
    ExprMissing(ExprMissing),
}
impl TypedSyntaxNode for Expr {
    fn missing(db: &dyn GreenInterner) -> GreenId {
        db.intern_green(GreenNode::Internal(GreenInternalNode {
            kind: SyntaxKind::ExprMissing,
            children: vec![],
            width: 0,
        }))
    }
    fn from_syntax_node(db: &dyn GreenInterner, node: SyntaxNode) -> Self {
        let green = db.lookup_intern_green(node.0.green);
        if let GreenNode::Internal(internal) = green {
            match internal.kind {
                SyntaxKind::ExprPath => {
                    return Expr::ExprPath(ExprPath::from_syntax_node(db, node))
                }
                SyntaxKind::ExprLiteral => {
                    return Expr::ExprLiteral(ExprLiteral::from_syntax_node(db, node))
                }
                SyntaxKind::ExprParenthesized => {
                    return Expr::ExprParenthesized(ExprParenthesized::from_syntax_node(db, node))
                }
                SyntaxKind::ExprUnary => {
                    return Expr::ExprUnary(ExprUnary::from_syntax_node(db, node))
                }
                SyntaxKind::ExprBinary => {
                    return Expr::ExprBinary(ExprBinary::from_syntax_node(db, node))
                }
                SyntaxKind::ExprMissing => {
                    return Expr::ExprMissing(ExprMissing::from_syntax_node(db, node))
                }
                _ => {
                    panic!("Unexpected syntax kind {:?} when constructing $(&name).", internal.kind)
                }
            }
        }
        panic!("Expected an internal node.");
    }
}
pub struct ExprPath(ElementList<PathSegment, 2>);
impl Deref for ExprPath {
    type Target = ElementList<PathSegment, 2>;
    fn deref(&self) -> &Self::Target {
        &self.0
    }
}
impl ExprPath {
    pub fn new_green(db: &dyn GreenInterner, children: Vec<GreenId>) -> GreenId {
        let width = children.iter().map(|id| db.lookup_intern_green(*id).width()).sum();
        db.intern_green(GreenNode::Internal(GreenInternalNode {
            kind: SyntaxKind::ExprPath,
            children,
            width,
        }))
    }
}
impl TypedSyntaxNode for ExprPath {
    fn missing(db: &dyn GreenInterner) -> GreenId {
        db.intern_green(GreenNode::Internal(GreenInternalNode {
            kind: SyntaxKind::ExprPath,
            children: vec![],
            width: 0,
        }))
    }
    fn from_syntax_node(db: &dyn GreenInterner, node: SyntaxNode) -> Self {
        Self(ElementList::new(node))
    }
}
pub struct PathSegment {
    node: SyntaxNode,
    children: Vec<SyntaxNode>,
}
impl PathSegment {
    pub fn new_green(db: &dyn GreenInterner, ident: GreenId, args: GreenId) -> GreenId {
        let children: Vec<GreenId> = vec![ident, args];
        let width = children.iter().map(|id| db.lookup_intern_green(*id).width()).sum();
        db.intern_green(GreenNode::Internal(GreenInternalNode {
            kind: SyntaxKind::PathSegment,
            children,
            width,
        }))
    }
    pub fn ident(&self, db: &dyn GreenInterner) -> Identifier {
        let child = self.children[0].clone();
        Identifier::from_syntax_node(db, child)
    }
    pub fn args(&self, db: &dyn GreenInterner) -> OptionGenericArgs {
        let child = self.children[1].clone();
        OptionGenericArgs::from_syntax_node(db, child)
    }
}
impl TypedSyntaxNode for PathSegment {
    fn missing(db: &dyn GreenInterner) -> GreenId {
        let children: Vec<GreenId> = vec![Identifier::missing(db), OptionGenericArgs::missing(db)];
        db.intern_green(GreenNode::Internal(GreenInternalNode {
            kind: SyntaxKind::PathSegment,
            children,
            width: 0,
        }))
    }
    fn from_syntax_node(db: &dyn GreenInterner, node: SyntaxNode) -> Self {
        let green = db.lookup_intern_green(node.0.green);
        match green {
            GreenNode::Internal(internal) => {
                if internal.kind != SyntaxKind::PathSegment {
                    panic!(
                        "Unexpected SyntaxKind {:?}. Expected {:?}.",
                        internal.kind,
                        SyntaxKind::PathSegment
                    );
                }
                let children = node.children(db);
                Self { node, children }
            }
            GreenNode::Token(token) => {
                panic!("Unexpected Token {:?}. Expected {:?}.", token, SyntaxKind::PathSegment);
            }
        }
    }
}
pub enum OptionGenericArgs {
    GenericArgs(GenericArgs),
    Empty(Empty),
}
impl TypedSyntaxNode for OptionGenericArgs {
    fn missing(db: &dyn GreenInterner) -> GreenId {
        db.intern_green(GreenNode::Internal(GreenInternalNode {
            kind: SyntaxKind::Empty,
            children: vec![],
            width: 0,
        }))
    }
    fn from_syntax_node(db: &dyn GreenInterner, node: SyntaxNode) -> Self {
        let green = db.lookup_intern_green(node.0.green);
        if let GreenNode::Internal(internal) = green {
            match internal.kind {
                SyntaxKind::GenericArgs => {
                    return OptionGenericArgs::GenericArgs(GenericArgs::from_syntax_node(db, node))
                }
                SyntaxKind::Empty => {
                    return OptionGenericArgs::Empty(Empty::from_syntax_node(db, node))
                }
                _ => {
                    panic!("Unexpected syntax kind {:?} when constructing $(&name).", internal.kind)
                }
            }
        }
        panic!("Expected an internal node.");
    }
}
pub struct GenericArgs(ElementList<Expr, 2>);
impl Deref for GenericArgs {
    type Target = ElementList<Expr, 2>;
    fn deref(&self) -> &Self::Target {
        &self.0
    }
}
impl GenericArgs {
    pub fn new_green(db: &dyn GreenInterner, children: Vec<GreenId>) -> GreenId {
        let width = children.iter().map(|id| db.lookup_intern_green(*id).width()).sum();
        db.intern_green(GreenNode::Internal(GreenInternalNode {
            kind: SyntaxKind::GenericArgs,
            children,
            width,
        }))
    }
}
impl TypedSyntaxNode for GenericArgs {
    fn missing(db: &dyn GreenInterner) -> GreenId {
        db.intern_green(GreenNode::Internal(GreenInternalNode {
            kind: SyntaxKind::GenericArgs,
            children: vec![],
            width: 0,
        }))
    }
    fn from_syntax_node(db: &dyn GreenInterner, node: SyntaxNode) -> Self {
        Self(ElementList::new(node))
    }
}
pub struct ExprLiteral {
    node: SyntaxNode,
    children: Vec<SyntaxNode>,
}
impl ExprLiteral {
    pub fn new_green(db: &dyn GreenInterner, terminal: GreenId) -> GreenId {
        let children: Vec<GreenId> = vec![terminal];
        let width = children.iter().map(|id| db.lookup_intern_green(*id).width()).sum();
        db.intern_green(GreenNode::Internal(GreenInternalNode {
            kind: SyntaxKind::ExprLiteral,
            children,
            width,
        }))
    }
    pub fn terminal(&self, db: &dyn GreenInterner) -> Terminal {
        let child = self.children[0].clone();
        Terminal::from_syntax_node(db, child)
    }
}
impl TypedSyntaxNode for ExprLiteral {
    fn missing(db: &dyn GreenInterner) -> GreenId {
        let children: Vec<GreenId> = vec![Terminal::missing(db)];
        db.intern_green(GreenNode::Internal(GreenInternalNode {
            kind: SyntaxKind::ExprLiteral,
            children,
            width: 0,
        }))
    }
    fn from_syntax_node(db: &dyn GreenInterner, node: SyntaxNode) -> Self {
        let green = db.lookup_intern_green(node.0.green);
        match green {
            GreenNode::Internal(internal) => {
                if internal.kind != SyntaxKind::ExprLiteral {
                    panic!(
                        "Unexpected SyntaxKind {:?}. Expected {:?}.",
                        internal.kind,
                        SyntaxKind::ExprLiteral
                    );
                }
                let children = node.children(db);
                Self { node, children }
            }
            GreenNode::Token(token) => {
                panic!("Unexpected Token {:?}. Expected {:?}.", token, SyntaxKind::ExprLiteral);
            }
        }
    }
}
pub struct ExprParenthesized {
    node: SyntaxNode,
    children: Vec<SyntaxNode>,
}
impl ExprParenthesized {
    pub fn new_green(
        db: &dyn GreenInterner,
        lparen: GreenId,
        expr: GreenId,
        rparen: GreenId,
    ) -> GreenId {
        let children: Vec<GreenId> = vec![lparen, expr, rparen];
        let width = children.iter().map(|id| db.lookup_intern_green(*id).width()).sum();
        db.intern_green(GreenNode::Internal(GreenInternalNode {
            kind: SyntaxKind::ExprParenthesized,
            children,
            width,
        }))
    }
    pub fn lparen(&self, db: &dyn GreenInterner) -> Terminal {
        let child = self.children[0].clone();
        Terminal::from_syntax_node(db, child)
    }
    pub fn expr(&self, db: &dyn GreenInterner) -> Expr {
        let child = self.children[1].clone();
        Expr::from_syntax_node(db, child)
    }
    pub fn rparen(&self, db: &dyn GreenInterner) -> Terminal {
        let child = self.children[2].clone();
        Terminal::from_syntax_node(db, child)
    }
}
impl TypedSyntaxNode for ExprParenthesized {
    fn missing(db: &dyn GreenInterner) -> GreenId {
        let children: Vec<GreenId> =
            vec![Terminal::missing(db), Expr::missing(db), Terminal::missing(db)];
        db.intern_green(GreenNode::Internal(GreenInternalNode {
            kind: SyntaxKind::ExprParenthesized,
            children,
            width: 0,
        }))
    }
    fn from_syntax_node(db: &dyn GreenInterner, node: SyntaxNode) -> Self {
        let green = db.lookup_intern_green(node.0.green);
        match green {
            GreenNode::Internal(internal) => {
                if internal.kind != SyntaxKind::ExprParenthesized {
                    panic!(
                        "Unexpected SyntaxKind {:?}. Expected {:?}.",
                        internal.kind,
                        SyntaxKind::ExprParenthesized
                    );
                }
                let children = node.children(db);
                Self { node, children }
            }
            GreenNode::Token(token) => {
                panic!(
                    "Unexpected Token {:?}. Expected {:?}.",
                    token,
                    SyntaxKind::ExprParenthesized
                );
            }
        }
    }
}
pub struct ExprUnary {
    node: SyntaxNode,
    children: Vec<SyntaxNode>,
}
impl ExprUnary {
    pub fn new_green(db: &dyn GreenInterner, op: GreenId, expr: GreenId) -> GreenId {
        let children: Vec<GreenId> = vec![op, expr];
        let width = children.iter().map(|id| db.lookup_intern_green(*id).width()).sum();
        db.intern_green(GreenNode::Internal(GreenInternalNode {
            kind: SyntaxKind::ExprUnary,
            children,
            width,
        }))
    }
    pub fn op(&self, db: &dyn GreenInterner) -> Terminal {
        let child = self.children[0].clone();
        Terminal::from_syntax_node(db, child)
    }
    pub fn expr(&self, db: &dyn GreenInterner) -> Expr {
        let child = self.children[1].clone();
        Expr::from_syntax_node(db, child)
    }
}
impl TypedSyntaxNode for ExprUnary {
    fn missing(db: &dyn GreenInterner) -> GreenId {
        let children: Vec<GreenId> = vec![Terminal::missing(db), Expr::missing(db)];
        db.intern_green(GreenNode::Internal(GreenInternalNode {
            kind: SyntaxKind::ExprUnary,
            children,
            width: 0,
        }))
    }
    fn from_syntax_node(db: &dyn GreenInterner, node: SyntaxNode) -> Self {
        let green = db.lookup_intern_green(node.0.green);
        match green {
            GreenNode::Internal(internal) => {
                if internal.kind != SyntaxKind::ExprUnary {
                    panic!(
                        "Unexpected SyntaxKind {:?}. Expected {:?}.",
                        internal.kind,
                        SyntaxKind::ExprUnary
                    );
                }
                let children = node.children(db);
                Self { node, children }
            }
            GreenNode::Token(token) => {
                panic!("Unexpected Token {:?}. Expected {:?}.", token, SyntaxKind::ExprUnary);
            }
        }
    }
}
pub struct ExprBinary {
    node: SyntaxNode,
    children: Vec<SyntaxNode>,
}
impl ExprBinary {
    pub fn new_green(
        db: &dyn GreenInterner,
        left: GreenId,
        op: GreenId,
        right: GreenId,
    ) -> GreenId {
        let children: Vec<GreenId> = vec![left, op, right];
        let width = children.iter().map(|id| db.lookup_intern_green(*id).width()).sum();
        db.intern_green(GreenNode::Internal(GreenInternalNode {
            kind: SyntaxKind::ExprBinary,
            children,
            width,
        }))
    }
    pub fn left(&self, db: &dyn GreenInterner) -> Expr {
        let child = self.children[0].clone();
        Expr::from_syntax_node(db, child)
    }
    pub fn op(&self, db: &dyn GreenInterner) -> Terminal {
        let child = self.children[1].clone();
        Terminal::from_syntax_node(db, child)
    }
    pub fn right(&self, db: &dyn GreenInterner) -> Expr {
        let child = self.children[2].clone();
        Expr::from_syntax_node(db, child)
    }
}
impl TypedSyntaxNode for ExprBinary {
    fn missing(db: &dyn GreenInterner) -> GreenId {
        let children: Vec<GreenId> =
            vec![Expr::missing(db), Terminal::missing(db), Expr::missing(db)];
        db.intern_green(GreenNode::Internal(GreenInternalNode {
            kind: SyntaxKind::ExprBinary,
            children,
            width: 0,
        }))
    }
    fn from_syntax_node(db: &dyn GreenInterner, node: SyntaxNode) -> Self {
        let green = db.lookup_intern_green(node.0.green);
        match green {
            GreenNode::Internal(internal) => {
                if internal.kind != SyntaxKind::ExprBinary {
                    panic!(
                        "Unexpected SyntaxKind {:?}. Expected {:?}.",
                        internal.kind,
                        SyntaxKind::ExprBinary
                    );
                }
                let children = node.children(db);
                Self { node, children }
            }
            GreenNode::Token(token) => {
                panic!("Unexpected Token {:?}. Expected {:?}.", token, SyntaxKind::ExprBinary);
            }
        }
    }
}
pub struct ExprMissing {
    node: SyntaxNode,
    children: Vec<SyntaxNode>,
}
impl ExprMissing {
    pub fn new_green(db: &dyn GreenInterner) -> GreenId {
        let children: Vec<GreenId> = vec![];
        let width = children.iter().map(|id| db.lookup_intern_green(*id).width()).sum();
        db.intern_green(GreenNode::Internal(GreenInternalNode {
            kind: SyntaxKind::ExprMissing,
            children,
            width,
        }))
    }
}
impl TypedSyntaxNode for ExprMissing {
    fn missing(db: &dyn GreenInterner) -> GreenId {
        let children: Vec<GreenId> = vec![];
        db.intern_green(GreenNode::Internal(GreenInternalNode {
            kind: SyntaxKind::ExprMissing,
            children,
            width: 0,
        }))
    }
    fn from_syntax_node(db: &dyn GreenInterner, node: SyntaxNode) -> Self {
        let green = db.lookup_intern_green(node.0.green);
        match green {
            GreenNode::Internal(internal) => {
                if internal.kind != SyntaxKind::ExprMissing {
                    panic!(
                        "Unexpected SyntaxKind {:?}. Expected {:?}.",
                        internal.kind,
                        SyntaxKind::ExprMissing
                    );
                }
                let children = node.children(db);
                Self { node, children }
            }
            GreenNode::Token(token) => {
                panic!("Unexpected Token {:?}. Expected {:?}.", token, SyntaxKind::ExprMissing);
            }
        }
    }
}
