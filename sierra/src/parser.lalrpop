// Simple parser for sierra.
// Currently only used for more easily writing tests.

use crate::graph::*;

grammar;

pub Program: Program = {
    <blocks:Block*> <funcs:Function*> => Program{blocks: blocks, funcs: funcs},
}

Block: Block = {
    <invcs:Invocation*> <exit:BlockExit> =>
        Block{invocations: invcs, exit: exit},
}

Function: Function = {
    <name:Label> "@" <entry:BlockId> "(" <args: TypedVars> ")" "->" "(" <res_types: Types> ")" ";" =>
        Function{name: name, args: args, res_types: res_types, entry: entry},
}

Invocation: Invocation = {
    <e:Extension> "(" <args:Identifiers> ")" "->" "(" <results:Identifiers> ")" ";" =>
        Invocation{ext: e, args: args, results: results},
}

BlockExit: BlockExit = {
    "return" "(" <args:Identifiers> ")" ";" => BlockExit::Return(args),
    <e:Extension> "(" <args:Identifiers> ")" "{" <branches:BranchInfo*> "}" ";" =>
        BlockExit::Jump(JumpInfo{ext:e, args: args, branches: branches}),
}

Extension: Extension = {
    <name:Label> "<" <tmpl_args:TemplateArgs> ">" =>
        Extension{name: name, tmpl_args: tmpl_args},
    <name:Label> => Extension{name: name, tmpl_args: vec![]},
}
 
Comma<T>: Vec<T> = { // (0)
    <mut v:(<T> ",")*> <e:T?> => match e { // (1)
        None=> v,
        Some(e) => {
            v.push(e);
            v
        }
    }
}; 

TemplateArgs = Comma<TemplateArg>;

TemplateArg: TemplateArg = {
    <v:UnsignedInt> => TemplateArg::Value(v),
    "-" <v:UnsignedInt> => TemplateArg::Value(-v),
    Type => TemplateArg::Type(<>),
}

TypedVars = Comma<TypedVar>;

TypedVar: TypedVar = {
    <id:Identifier> ":" <ty:Type> => TypedVar{id: id, ty: ty},
}

Types = Comma<Type>;

Type: Type = {
    <name:Label> "<" <args:TemplateArgs> ">" => Type{name: name, args: args},
    <name:Label> => Type{name: name, args: vec![]},
}

BranchInfo: BranchInfo = {
    <target: BranchTarget> "(" <exports:Identifiers> ")" =>
        BranchInfo{ target: target, exports: exports },
}

BranchTarget: BranchTarget = {
     "fallthrough" => BranchTarget::Fallthrough,
     <b:BlockId> => BranchTarget::Block(b),
}


Identifiers = Comma<Identifier>;

Identifier: Identifier = {
    Label => Identifier(<>),
}

BlockId: BlockId = {
     <b:UnsignedInt> => BlockId(b as usize),
}

Label: String = {
    r"[a-zA-Z_][a-zA-Z_0-9]*" => <>.to_string(),
}

UnsignedInt: i64 = {
    r"[1-9][0-9]*" => <>.parse().unwrap(),
    "0" => 0,
}

match {
    r"\s*" => {},
    r"#[^\n\r]*[\n\r]*" => {},
    _,
}
